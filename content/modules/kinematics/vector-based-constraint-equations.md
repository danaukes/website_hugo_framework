---
title: Vector Constraint Equations
type: submodule
---

# Vector Constraint Equations

## v,w perpendicular {#sec:perpendicular_constraint}

Here the intuition is that perpendicular lines have an angle of $\theta$ between them. This means that the expression for dot product or cross product can be used, as both use $\theta$. The dot product produces a scalar result, however, while the result of a cross product is a vector, meaning that all three elements of the vector must equal zero; hence we pick the dot product expression. Using , we substitute $\theta = \frac{\pi}{2}$ into the expression, resulting in the simplified $$
\vec{v}\cdot\vec{w}=0.$$ When broken out into basis vectors $\hat{a}_x$,$\hat{a}_y$,and $\hat{a}_z$, the expression becomes $$
v_x w_x +v_y w_y +v_z w_z = 0$$

## v,w parallel {#sec:parallel_constraint}

The intuition here is the same as above, except that we substitute the expression $\theta = 0$ into , because parallel lines have an angle of zero between them. This results in $$
\vec{v}\cdot\vec{w}=|v||w|.$$ In expanded form, this looks like $$
v_x w_x +v_y w_y +v_z w_z = \sqrt{(v_x^2+v_y^2+v_z^2)(w_x^2+w_y^2+w_z^2)}
$$

## point(p) on line(q,r)

using the ideas of , we construct two vectors. The first is a vector between some point on the line, q, and the point p.Â The second vector is a vector of the line itself. For the point p to be on the line, the two lines must be parallel. 
$$\text{given }\vec{a} = \vec{p} - \vec{q} \text{ and}\\
\vec{b} = \vec{r} - \vec{q},\\
\vec{a}\cdot\vec{b} = |\vec{a}||\vec{b}|.$$

## distance between p and q is l {#sec:length_constraint}

in this case, we create a vector between points p and q, and use to retrieve its magnitude. $$
|\vec{p} - \vec{q}| = l \label{eqn:length_constraint}$$ In expanded form, $$
\sqrt{(p_x-q_x)^2 +(p_y-q_y)^2 + (p_z-q_z)^2} = l \label{eqn:length_constraint_expanded}.$$

## loop constraints

A loop is a vector that ends where it began. If you think about generic mechanisms as branching articulated bodies, sometimes those branches meet back up at their ends to create closed kinematic chains with interesting motion. One example is the locomotive engine, which consists of a crank connected to a piston which slides. Other common devices include four-bar mechanisms, which can be found in pantographs, prosthetic knees, and the jaws of some fish.

### Loop Example {#loop-example .unnumbered}

There are four vectors, $\vec{a}$,$\vec{b}$,$\vec{c}$, and $\vec{d}$ for whom $$
\vec{a} + \vec{b} + \vec{c}+ \vec{d} =\vec{0}$$ in expanded form, with basis vectors $\hat{n}_x$,$\hat{n}_y$,$\hat{n}_z$ $$
(a_x +b_x + c_x + d_x)\hat{n}_x
+(a_y +b_y + c_y + d_y)\hat{n}_y
+(a_z +b_z + c_z + d_z)\hat{n}_z  \nonumber \\
= 0\hat{n}_x +0\hat{n}_y +0\hat{n}_z$$ This is a vector equation, however, and we are more interested in generating a set of scalar equations. To accomplish this, we may dot the entire expresssion with a basis vector to convert the vector expression into a scalar expression. This may be done for each of the three basis vectors. For $\hat{n}_i$, where $i=(x,y,z)$, $$
(\vec{a} + \vec{b} + \vec{c}+ \vec{d})\cdot \hat{n}_i = \vec{0} \cdot \hat{n}_i\text{, resulting in } \\
a_x +b_x + c_x + d_x = 0\\
a_y +b_y + c_y + d_y = 0\\
a_z +b_z + c_z + d_z = 0$$ We are left with three scalar constraint equations

## Origami Systems

Using the results of the last section, we can finally start to make a system for analyzing generic origami structures. You can think of an idealized origami system as a set of rigid faces which are permitted to rotate about each other at the fold lines. An ideal origami face is rigid, *i.e.* any motion in the system occurs between faces, along the fold lines. Rigidity in the faces preserves face edge lengths, and as discussed in , the distance between two points can be expressed with . This allows us to create a system of equations which expresses the motion of the origami system with regard to those fold lines.

## Counting Degrees of Freedom

There is a fairly straightforward way to count the number of degrees of freedom in an origami design. Here are the steps:

1.  Draw your origami structure(black for outline, red for mountain, blue for valley)

2.  Split any polygons with $>3$ sides into triangles by adding green lines

3.  Draw vertices where any two lines meet

4.  Number each line as $l_i$. Set \$m = \$ the total number of all lines(black,red,blue,green)

5.  Number each vertex as $v_i$. Set \$n = \$ the total number of vertices.

6.  Count $r$, the number of rigid(green) lines

7.  Determine $f$, the degrees of freedom of your system using $f = 3n-m-r-6$

## Assembling the constraint equations {#sec:origami_constraint_equations}

1.  The first set of equations is generated by directly defining the locations of one triangular face. For each vertex $v_i$ on such a fixed face, $$
    v_{ix} - x_i  = 0\\
    v_{iy} - y_i =0\\
    v_{iz} - z_i=0,
    $$

    where $x_i$, $y_i$ and $z_i$ are the positions of each point in x, y, and z coordinates. Repeated over the three vertices, this should produce 9 equations.

2.  For each line $l_i$ that is not on the edge of the fixed face, there should be two vertices, $v_j$ and $v_k$ connected to it. Using the expanded form of the length constraint , create an equation which should look like $$
    v_{jx}v_{kx}+v_{jy}v_{ky}+v_{jz}v_{kz} - \ell_i=0,
    $$

    where $\ell_i$ is the length of line $l_i$. This should be done $m-3$ times.

3.  For each green line, there is an additional constraint that the two neighboring faces are parallel to each other. let vertices $v_i$ and $v_j$ be the two vertices shared by the fixed(green) line, and vertices $v_a$ and $v_b$ be the remaining vertices of the two faces.

$$
    \vec{a}=\vec{v}_a - \vec{v}_i \\
    \vec{b}=\vec{v}_b - \vec{v}_i \\
    \vec{c}=\vec{v}_j - \vec{v}_i \\
    \vec{d}=\vec{c}\times\vec{a}\\
    \vec{e}=\vec{b}\times\vec{c}$$ Using the parallel constraint equation generates an extra equation per rigid line,

$$
    \vec{d} \cdot \vec{e} - |\vec{d}||\vec{e}| = 0.$$ this should be done $r$ times.

There should be a total of $c=9+(m-3)+r$ equations derived from the above three steps. Alternative derivations are possible, but this recipe is one of the more straightforward.

## Creating the Jacobian

Each constraint equation from establishes a relationship between one or more of the variables that determine the vertices' positions. By taking the partial derivative of each equation with respect to each of those variables, we are able to understand how the velocity of one variable influences the velocity of the other variables. These partial derivatives can be assembled into a Jacobian matrix, which can be used to establish motion profiles for an origami mechanism. Let $\mathbf{e} = \left[\begin{matrix}e_1 &\ldots &e_c\end{matrix}\right]^T,$, where $e_i$ is the $i$th constraint equation. $\mathbf{J}$ can therefore be defined as $$
\mathbf{J} = \left[
\begin{matrix}
\frac{\partial \mathbf{e}}{\partial v_{1x}} & \frac{\partial \mathbf{e}}{\partial v_{1y}} & \frac{\partial \mathbf{e}}{\partial v_{1z}} & \ldots & \frac{\partial \mathbf{e}}{\partial v_{nx}} &\frac{\partial \mathbf{e}}{\partial v_{ny}} & \frac{\partial \mathbf{e}}{\partial v_{nz}}\\
\end{matrix}
\right]
$$
